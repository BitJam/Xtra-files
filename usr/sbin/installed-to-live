#!/bin/bash
#
# Start:
# 1) Bind mount the bind-root
#
# General
# 2) do a bunch of bind mounts under bind-root
#    (create directories and touch files as needed)
# 3) Munge files
#
# Add:
# 4) optionally do more bind mounts under ro-root
#    (create directories and touch files as needed)

# Clean:
# 5) do a recursive umount
# 6) Delete touched files and created directories from the *original* FS


ME=${0##*/}

USER_PW=demo:demo
ROOT_PW=root:root

BIND_ROOT=/bind-root
REAL_ROOT=/
WORK_DIR=/tmp/$ME

CONF_FILE=$WORK_DIR/cleanup.conf

TEMPLATE_DIR=/usr/local/share/live-files

PRETEND=

PW_FILES="/etc/passwd /etc/shadow /etc/gshadow /etc/group"
MUNGE_FILES="/etc/slim.conf /etc/lightdm/lightdm.conf"
BIND_FILES="$PW_FILES $MUNGE_FILES"

usage() {
    local ret=${1:-0}

    cat<<Usage
Usage: $ME [options] [commands ...]
Use bind mounts to create a filesystem that looks like the live system.

Create a config file $CONF_FILE that can be used to undo what we did.
This is needed because sometimes we create directories and touch files.

Commands:
    start      Do the main bind mount and create cleanup.conf
    status     Show status including contents of cleanup.conf
    general    Make it general purpose
    passwd     Only make general purpose password/group files
    add=<dir>  Add files from the <dir> template
    cleanup    Clean up all that we did

Options:

    -b --bind-root=<dir>       The root of the new fs.   Default: $BIND_ROOT
    -e --empty=<dir1,dir2,...> Directories that will be bind mounted to empty directories
    -f --from=<dir>            Directory we copy from.  Default: $REAL_ROOT
    -F --Force                 Delete work directory when starting
    -h --help                  Show this help
    -P --pretend               Don't do anything just show what would be done
    -r --root=<user:password>  The root user and optional password
    -t --template=<dir>        Template directory
    -u --user=<user:password>  Default username and optional password
    -w --work=<dir>            Temporary directory to hold our work: $WORK_DIR

    -v --verbose                Print more
    -q --quiet                  Print less

Note: if passwords aren't given then the username is used as the password.

Current defaults:
--bind-root=$BIND_ROOT
     --from=$REAL_ROOT
 --template=$TEMPLATE_DIR

     --user=$USER_PW
     --root=$ROOT_PW
Usage

    exit $ret
}

main() {

    [ $# -eq 0 ] && usage

    local param val
    local short_stack="befFhprtuvq"
    while [ $# -gt 0 -a -n "$1" -a -z "${1##-*}" ]; do
        param=${1#-}
        shift

       # Unstack single-letter options
        case $param in
            [$short_stack][$short_stack]*)
                if [ -z "${param//[$short_stack]/}" ]; then
                    set -- $(echo $param | sed -r 's/([a-zA-Z])/ -\1 /g') "$@"
                    continue
                fi;;
        esac

        case $param in
            -bind-root|-empty|-from|-root|-template|-user|-work|[befrtuw])
                    [ $# -lt 1 ] && fatal "Expected a parameter after: -$param"
                    val=$1
                    [ -n "$val" -a -z "${val##-*}" ] \
                        && fatal "Suspicious parameter after -$param: $val"
                    shift           ;;

              *=*)  val=${param#*=} ;;
                *)  val="???"       ;;
        esac

        case $param in
          -bind-root=*|b=*) BIND_ROOT=$val                    ;;
              -bind-root|b) BIND_ROOT=$val                    ;;
                  -empty|e) EMPTY_DIRS=${EMPTY_DIRS:+,}$val   ;;
              -empty=*|e=*) EMPTY_DIRS=${EMPTY_DIRS:+,}$val   ;;
               -from=*|f=*) REAL_ROOT=$val                    ;;
                   -from|f) REAL_ROOT=$val                    ;;
                  -Force|F) FORCE=true                        ;;
                   -help|h) usage                             ;;
                -pretend|p) PRETEND=true                      ;;
                  -quiet|q) QUIET=true                        ;;
               -root=*|r=*) ROOT_PW=$val                      ;;
                   -root|r) ROOT_PW=$val                      ;;
           -template=*|t=*) TEMPLATE_DIR=$val                 ;;
               -template|t) TEMPLATE_DIR=$val                 ;;
               -user=*|u=*) USER_PW=$val                      ;;
                   -user|u) USER_PW=$val                      ;;
                -verbose|v) VERBOSE=true                      ;;
               -work=*|w=*) WORK_DIR=$val                     ;;
                  -work|w=) WORK_DIR=$val                     ;;
                         *) fatal "Unknown argument: -$param" ;;
        esac
    done

    CONF_FILE=$WORK_DIR/cleanup.conf

    [ $# -eq 0 ] && fatal "Expected as least one commmand"

    local cmd
    for cmd; do
        case $cmd in
              start) do_start   $CONF_FILE $WORK_DIR           ;;
             status) do_status  $CONF_FILE                     ;;
                add) do_add     $CONF_FILE $WORK_DIR           ;;
              add=*) do_add     $CONF_FILE $WORK_DIR ${cmd#*=} ;;
            general) do_general $CONF_FILE                     ;;
             passwd) do_passwd  $CONF_FILE                     ;;
            cleanup) do_cleanup $CONF_FILE $WORK_DIR           ;;
                  *) fatal "Unexpected command: $cmd.\nExpected: start, status, add, add=dir, general, passwd, or cleanup"
        esac
    done
}

do_start() {
    local conf_file=$1  work_dir=$2

    [ -z "$FORCE" -a -e "$work_dir" ] && fatal "Work dir $work_dir exists.  Use --Force to delete it"
    test -e $work_dir && rm -rf $work_dir

    mkdir -p $BIND_ROOT
    if mountpoint -q $BIND_ROOT &>/dev/null; then

        [ -z "$FORCE" ] && fatal "bind-root: $BIND_ROOT is already a mount point"

    else
        mount --bind $REAL_ROOT $BIND_ROOT
    fi

    write_conf_file $conf_file
}

do_add() {
    local conf_file=$1  work_dir=$2  template_dir=$3

    read_conf_file $conf_file

    if [ "$template_dir" ]; then
        test -d $template_dir || fatal "Template dir: $template_dir is not a directory"
        bind_mount_template "$template_dir" "$BIND_ROOT" "$REAL_ROOT"
    fi

    bind_empty_dirs "$WORK_DIR/empty" "$BIND_ROOT" "$REAL_ROOT" $EMPTY_DIRS

    write_conf_file $CONF_FILE
}

do_status() {
    local conf_file=$1

    echo "$ME status:"
    if ! read_conf_file $conf_file force; then
        echo "  unstarted"
        exit 1
    fi

    echo "  started"

    if ! test -d $BIND_ROOT; then
        echo "  BIND_ROOT: $BIND_ROOT is not a directory"
    elif mountpoint -q $BIND_ROOT; then
        echo "  BIND_ROOT: $BIND_ROOT is mounted"
    else
        echo "  BIND_ROOT: $BIND_ROOT is not mounted"
    fi

    echo
    echo "  Config file:"
    echo ">>>>>>>>>>"
    cat $conf_file
    echo "<<<<<<<<<<"

    [ "$VERBOSE" ] || exit 0
    echo
    echo ">> df -a | grep $BIND_ROOT | awk '{print \$6}'"
    df -a | grep $BIND_ROOT | awk '{print $6}'

    exit 0
}


do_passwd() {
    local conf_file=$1
    read_conf_file $conf_file

    munge_files         "$TEMPLATE_DIR"   "$BIND_ROOT" "$WORK_DIR" "$USER_PW" "$ROOT_PW"

    write_conf_file $CONF_FILE
}


do_general() {
    local conf_file=$1
    read_conf_file $conf_file

    bind_mount_template "$TEMPLATE_DIR"   "$BIND_ROOT" "$REAL_ROOT"
    bind_empty_dirs     "$WORK_DIR/empty" "$BIND_ROOT" "$REAL_ROOT" $EMPTY_DIRS
    #munge_files         "$TEMPLATE_DIR"   "$BIND_ROOT" "$WORK_DIR" "$USER_PW" "$ROOT_PW"

    write_conf_file $CONF_FILE
}

do_cleanup() {
    local conf_file=$1  work_dir=$2
    read_conf_file $conf_file $FORCE

    local i
    for i in $(seq 1 10); do
        mountpoint $BIND_ROOT -q &>/dev/null || break
        pretend umount --recursive $BIND_ROOT
        [ "$PRETEND" ] && break
    done

    [ -z "$PRETEND" ] && mountpoint $BIND_ROOT -q &>/dev/null && fatal "Could not umount $BIND_DIR"

    local file dir
    echo "$RM_FILES" | tr ',' '\n' | tac | while read file; do
	[ "$file" ] || continue
        pretend rm -f "$file"
    done

    echo "$RM_DIRS" | tr ',' '\n' | tac | while read dir; do
	[ "$dir" ] || continue
        pretend rmdir --ignore-fail-on-non-empty --parents "$dir"
    done

    pretend rm -f $conf_file
    [ "$work_dir" ] && pretend rm -rf $work_dir
    exit 0
}

bind_mount_template() {
    local template_dir=$1  bind_root=$2  real_root=$3

    # Remove trailing slash from real_root and template_dir
    real_root=${real_root%/}
    template_dir=${template_dir%/}

    test -d $template_dir || return
    local file
    while read file; do
        local base=${file#$template_dir}
        local targ=$bind_root$base
        touch_file "$targ" "$real_root$base"
        pretend mount --bind $file $targ
    done <<Bind_Template
$(find $template_dir -type f)
Bind_Template
}

bind_empty_dirs() {
    local template_dir=$1  bind_root=$2  real_root=$3  dirs=$4

    # Remove trailing slash from real_root
    real_root=${real_root%/}

    local base
    echo "$dirs" | tr ',' '\n' | tac | while read base; do
        [ "$base" ] || continue
        local targ=$bind_root/$base
        # If directory doesn't exist then skip it
        test -d $targ || continue
        make_dir "$targ" "$real_root/$base"
        pretend mkdir -p $template_dir/$base
        pretend mount --bind $template_dir/$base $targ
    done
}

make_dir() {
    local dir=$1  orig=$2
    test -d $dir && return
    RM_DIRS="$RM_DIRS${RM_DIRS:+,}$orig"
    pretend mkdir -p $dir
}

touch_file() {
    local file=$1  orig=$2
    local dir=$(dirname $file)
    make_dir "$dir" "$(dirname $orig)"
    test -f $file && return
    test -e $file && fatal "Expected a plain file at $orig"

    RM_FILES="$RM_FILES${RM_FILES:+,}$orig"

    pretend touch $file
}

munge_files() {
    local template_dir=$1  bind_root=$2  work_dir=$3  user_pw=${4:-demo}  root_pw=${5:-root}
    local bind_from=$work_dir/bind

    local def_user=${user_pw%%=*}

    local empty_dir=$work_dir/empty
    mkdir -p $empty_dir

    # create lists of pw_files and grp_files that actually exist
    local file pw_files grp_files
    for file in $PW_FILES; do
        test -e $bind_root$file || continue
        pw_files="$pw_files $bind_from$file"
        case $file in
            */group|*/gshadow) grp_files="$grp_files $bind_from$file";;
        esac
    done

    # Ensure we have a user with uid=1000 in the real system
    local added_user
    local user_1000=$(cut -d: -f1,3 /etc/passwd | grep :1000$ | cut -d: -f1)
    if [ -z "$user_1000" ]; then

        # Don't assume there is no demo user but still try it first
        user_1000=$def_user
        while grep -q "^$user_1000:" /etc/passwd; do
            user_1000=a$(dd if=/dev/urandom bs=1 count=40 2>/dev/null | md5sum | cut -c 1-9)
        done

        adduser --disabled-login --uid=1000 --no-create-home --gecos $def_user $user_1000
        added_user=true
    fi

    # Copy in files to the bind_from *after* we've added user_1000 (if needed)
    # Use files from template_dir first if they are available.
    local live_files
    for file in $BIND_FILES; do
        test -e $bind_root$file || continue
        dir=$(dirname $file)
        bdir=$bind_from$dir

        # Don't munge files that have a template file
        [ "$template_dir" -a -e $template_dir$file ] && continue
        pretend mkdir -p $bdir

        # Probably makes no difference that we copy from bind_root, not real_root
        pretend cp -a $bind_root$file $bdir
    done

    # Remove the added user from the originals (but it is still in the copies
    # under bind_from/)
    [ "$added_user" ] && deluser $user_1000

    # Modify files (under bind_from/)

    # Remove all other normal users from the passwd and group files
    # Normal means having a home dir under /home and a login shell that ends in "sh"
    local other_users=$(cut /etc/passwd -d: -f1,6,7 | grep ":/home/.*:.*sh$" | cut -d: -f1 \
        | grep -v "^$user_1000$")

    local other_user_regex=$(echo $other_users | tr " " '|')
    pretend sed -i -r "/^($other_user_regex):/d" $pw_files
    pretend sed -i -r -e "s/:($other_user_regex)(,|$)/:/" -e "s/,($other_user_regex)(,|$)/\2/" $grp_files

    # Replace user_1000 with def_user (demo) if needed
    if [ $user_1000 != $def_user ]; then
        pretend sed -i -r "s/^$user_1000:/$def_user:/" $pw_files
        pretend sed -i -r -e "s/:$user_1000(,|$)/:$def_user/" -e "s/,$user_1000(,|$)/,$def_user\1/" $grp_files
    fi

    do_sed $bind_from/etc/slim.conf \
        -e "s/^(\s#)*(default_user +).*/\2$def_user/" \
        -e "/xserver_arguments/ s/ -dpi\s+[0-9]+//"   \
        -e "s/^(\s#)*(auto_login +).*/\2yes/"

    do_sed $bind_from/etc/lightdm/lightdm.conf \
        -e "/autologin-user=demo/ s/^#+//" \
        -e "/xserver-command/ s/ -dpi [0-9]+//"

    set_password $user_pw $bind_from
    set_password $root_pw $bind_from

    # Bind mount files under $bind_from/
    for file in $BIND_FILES; do
        test -e $bind_root$file || continue
        pretend mount --bind $bind_from$file $bind_root$file
    done
}

do_sed() {
    local file=$1
    shift
    echo sed $* $file
    if [ "$PRETEND" ]; then
        local expr
        file=${file/$bind_from/$real_root}
        test -e $file || return
        for expr; do
            [ "$expr" = -e ] && continue
            echo sed -n -r "${expr}" $file
            sed -n -r "${expr}p" $file
        done
    else
        test -e $file || return
        pretend sed -i -r "$@" $file
    fi
}

# first param is "username=password" and the "=password" part is optional
# If the password is empty then we use the username for the password.
# Second param is a "chroot" directory containing the /etc/shadow file.
set_password() {
    local user_pw=$1  dir=$2
    local user=${user_pw%%:*}
    local pw=${user_pw#*:}
    : ${pw:=$user}
    local hash=$(mkpasswd -m sha-512 "$pw")
    pretend sed -n -r "s=^($user):[^:]*:=\1:$hash=p" $dir/etc/shadow
}

write_conf_file() {
    local file=$1
    mkdir -p $(dirname $file)
    cat <<Conf_File > $file
REAL_ROOT="$REAL_ROOT"
BIND_ROOT="$BIND_ROOT"
RM_DIRS="$RM_DIRS"

RM_FILES="$RM_FILES"
Conf_File
}

read_conf_file() {
    local conf_file=$1  force=$2

    if ! test -r $conf_file; then
        [ "$force" ] || fatal "Could not find config file $conf_file"
        return 1
    fi

    . $conf_file

    return 0
}

fatal() {
    local msg=$1  ret=${2:-2}
    echo -e "$ME Fatal Error: $msg" >&2
    exit $ret
}

error() {
    local msg=$1
    echo -e "$ME Error: $msg" >&2
}


pretend() {
    [ "$PRETEND" -o "$VERBOSE" ] && echo "$@"
    [ "$PRETEND" ] && return
    "$@"
}

main "$@"

